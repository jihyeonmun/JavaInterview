# 0.Q&A

### 1. 자바의 특징에 대해 말해보시오.
1) OOP(객체 지향 언어) 
    : 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해 전체 프로그램을 완성하는 개발 기법
2) "가비지 컬렉션"에 의한 메모리 자동 관리
3) "멀티 쓰레드"를 지원한다.
4) JVM 위에서 동작하기 때문에 특정 OS에 종속적이지 않고 이식성이 좋으며, 보안성이 좋다.
5) 다양한 Open 라이브러리들이 존재한다.

### 2. 자바를 만든 사람에 대해 아시나요?
: "제임스 고슬링"

### 3. 변수란?
: "하나의 값을 저장할 수 있는 메모리 공간"

### 4. 객체와 클래스의 차이점에 대해 설명해 보시오.
- 클래스(Class) : 현실 세계의 객체의 속성과 동작을 추려내 필드와 메서드로 정의한 것으로 "아직 메모리가 할당되지 않은 상태"
vs
- 객체(Object) : 이 Class라는 설계도를 기반으로 실제 메모리가 잡힌 것을 의미하며 이런 객체를 조합해 전체 프로그램을 완성해
   나가는 방식을 OOP(객체지향 프로그래밍)이라고 한다.

### 5. 객체 지향 PG이란? 또 그 특징은?
: 현실세계의 객체를 필드와 메서드로 정의한 Class를 기반으로 실제 메모리가 잡혀 만들어진 부품과 같은 객체들을 조합해
  전체 프로그램을 완성해 나가는 개발 기법으로
특징)
- 캡슐화, 은닉화 : 외부 객체에서 구현방식은 알 수 없도록 숨기고 별도로 접근할 수 있는 getter/setter 메서드를 통해 접근하도록 하는 방식
- 상속 : 부모 Class를 자식이 접근할 수 있도록 물려 받는 방식
- 다형성 : 부모 클래스 타입으로 해당 부모를 상속받는 여러 자식 class를 대입할 수 있는 성질
등을 들 수 있다.

### 6. 다형성이란?
: 서로 다른 클래스로부터 만들어진 객체지만 같은 부모의 Class 타입으로 이들을 관리할 수 있는(=대입될 수 있는) 성질

### 7. 자바의 메모리 영역(간단하게 설명)
1. 메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.
    , 코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.
2. 스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리
3. 힙(Heap) : new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

|자바 메모리 구조|자바 메모리 영역|
|:--:|:--:|
|![자바 메모리 구조](https://t1.daumcdn.net/cfile/tistory/2540294C5654207F26)|![자바 메모리 영역](https://media.vlpt.us/images/ditt/post/02eb60d1-7053-4642-9a3c-b434e5b2c81d/image.png)|

### 7-1.JVM 구조?
- 실행될 클래스 파일을 메모리에 로드 후 초기화 작업 수행
- 메소드와 클래스변수들을 해당 메모리 영역에 배치
- 클래스로드가 끝난 후 JVM은 Main 메소드를 찾아 지역변수, 객체 변수, 참조변수를 스택에 쌓음.
- 다음 라인을 진행하면서 상황에 맞는 작업 수행(함수 호출, 객체 할당 등)
- Class Loader : JVM 내로 클래스를 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈로써 런타임시 동적으로 클래스를 로드한다.
- Executtion Engine : Class Loader를 통해 JVM 내의 런타임 영역에 배치된 바이트 코드를 실행한다. 이 때, Execution Engine은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
- Garbage Collector : JVM은 Garbage Collector를 통해 메모리 관리 기능을 자동으로 수행한다. 애플리케이션이 생성한 객체의 생존 여부를 판단하여 더 이상 사용되지 않는 객체를 해제하는 방식으로 메모리를 자동 관리한다.
- Runtime Data Areas : JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. Class Loader에서 준비한 데이터들을 보관하는 저장소이다. 

### 7-2. Runtime Data Areas? -> 일반적으로 얘기 하는 메모리 영역 

|Runtime Data Areas|
|:--:|
|![Runtime](https://t1.daumcdn.net/cfile/tistory/216AE04C5654207F0A)|

- Method (Static) Area: JVM이 읽어들인 클래스와 인터페이스 대한 런타임 상수 풀, 멤버 변수(필드), 클래스 변수(Static 변수), 생성자와 메소드를 저장하는 공간이다.
- Runtime Constant Pool
    - 메소드 영역에 포함되지만 독자적 중요성이 있다.
    - 클래스 파일 constant_pool 테이블에 해당하는 영역이다.
     - 클래스와 인터페이스 상수, 메소드와 필드에 대한 모든 레퍼런스를 저장한다.
     - JVM은 런타임 상수 풀을 통해 해당 메소드나 필드의 실제 메모리 상 주소를 찾아 참조한다
- 메소드 영역/런타임 상수 풀의 사용기간 및 스레드 공유 범위
    - JVM 시작시 생성
    - 프로그램 종료 시까지
    - 명시적으로 null 선언 시
    - 구성 방식이나 GC 방법은 JVM 벤더마다 다를 수 있다.
    - 모든 스레드에서 공유한다.
- Heap Area
    - JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역이다.
    - New 연산자로 생성된 객체 또는 객체(인스턴스)와 배열을 저장한다.
    - 힙 영역에 생성된 객체와 배열은 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
    - 참조하는 변수나 필드가 없다면 의미 없는 객체가 되어 GC의 대상이 된다.
    - 힙 영역의 사용기간 및 스레드 공유 범위
    1) 객체가 더 이상 사용되지 않거나 명시적으로 null 선언 시
    2)GC(Garbage Collection) 대상
    3)구성 방식이나 GC 방법은 JVM 벤더마다 다를 수 있다.
    4)모든 스레드에서 공유한다.
- Stack Area
    - 각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 할당된다.
    - 메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다.
    - 선입후출(FILO, First In Last Out) 구조로 push와 pop 기능 사용
    - 메소드 호출 시 생성되는 스레드 수행정보를 기록하는 Frame을 저장
    - 메소드 정보, 지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장
    - 기본(원시)타입 변수는 스택 영역에 직접 값을 가진다.
    - 참조타임 변수는 힙 영역이나 메소드 영역의 객체 주소를 가진다.
- PC Register
    - 현재 수행 중인 JVM 명령 주소를 갖는다.
    - 프로그램 실행은 CPU에서 인스트럭션(Instruction)을 수행.
    - CPU는 인스트럭션을 수행하는 동안 필요한 정보를 CPU 내 기억장치인 레지스터에 저장한다.
    - 연산 결과값을 메모리에 전달하기 전 저장하는 CPU 내의 기억장치
 - Native Method Stack Area
    - 자바 외 언어로 작성된 네이티브 코드를 위한 Stack이다.
    - 즉, JNI(Java Native Interface)를 통해 호출되는 C/C++ 등의 코드를 수행하기 위한 스택이다.
    - 네이티브 메소드의 매개변수, 지역변수 등을 바이트 코드로 저장한다.
- Heap Area
    - Young Generation: 이 영역은 자바 객체가 생성되자마자 저장되고, 생긴지 얼마 안되는 객체가 저장되는 공간이다. 시간이 지나 우선순위가 낮아지면 Old 영역으로 옮겨진다. 이 영역에서 객체가 사라질 때 Minor GC가 발생한다.
    - Old(Tenured) Generation: Young Generation 영역에서 저장되었던 객체 중에 오래된 객체가 이동되어 저장되는 영역이다. 이 영역에서 객체가 사라질 때 Major GC(Full GC)가 발생한다.
- None Heap Area
    - Permanent Generation(Java 7 이전): 클래스 로더에 의해 로드되는 클래스, 메소드 등에 대한 메타 정보가 저장되는 영역으로 JVM에 의해 사용된다. 리플렉션을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다. 내부적으로 리플렉션 기능을 자주 사용하는 Spring Framework를 이용할 경우 이 영역에 대한 고려가 필요하다. 런타임시 사이즈를 조절할 수 없어 OutOfMemoryError: PermGen Space error 가 발생하는 메모리 영역이다. JVM 실행시 PermSize와 MaxPermSize 옵션을 사용한다.
    - Metaspace(Java 8 이후): Permanent Generation이 Metaspace로 변경 되었다. 기능은 비슷하지만, 주요 차이점은 동적으로 사이즈를 바꿀 수 있다. JVM 옵션도 PermGem관련하여 사라지고, Metaspace 관련하여 MetaspaceSize 및 MaxMEtaspaceSize 옵션이 새로 생겼다.

출처: https://hoonmaro.tistory.com/19 [훈마로의 보물창고]

### 8. 추상메서드? 추상 클래스?
- 추상메서드 : 메서드의 정의부만 있고 구현부는 있지 않은 메서드
- 추상 클래스 : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서 오버라이딩(재정의)가 필요한 추상메서드를 가지고 있기
        때문에 객체화 할 수 없다.

### 9. 인터페이스(Interface)란? 또 왜 사용하나?
: 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로
  정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.

왜 인터페이스를 사용하는가? 
: 팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의
  메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의
  작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.
  또한, 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기 위해서 Comparable 인터페이스를 
  상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.

### 10. 프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?
- 프로세스 : OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에
    서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요하다.
- 쓰레드 : 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의
  자원(메모리)는 프로세스 내에서 공유하게 된다.


### 11. 컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.

- Collection 인터페이스 
- List 인터페이스 : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.
ex) - ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를
옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.
    - LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만
연결하면 되기 때문에 삽입, 삭제에 유리하다.
    - Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리
Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.
- Set 인터페이스 : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우
  Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.
ex) - HashSet
    - TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

- Map 인터페이스 : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.
ex) - HashMap
     - TreeMap
     - Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.
     - Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.

### 12. 캐시(Cache)와 세션(Session)의 공통점과 차이점은?
- 공통점 : 둘 다 사용자의 데이터를 저장한다.
- 차이점
- 캐시 : 캐시는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.
- 세션 : 세션은 서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.

### 13. Request 전송 방식에는 어떤 것들이 있는지 아시나요?
- Get 방식 : URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.
- POST 방식 : 헤더에 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.
- DELETE 방식 : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.
- PUT/PUSH 방식 : RESTFUL에서 수정 작업을 할 때 주로 사용된다.

### 14. RESTFUL이란?
: 해당 URL만 보더라도 바로 어떤 작업을 하는지를 알 수 있도록 하나의 데이터는 하나의 URL을 갖도록 작업하는 방식

### 15. Spring에서 DI란 무엇인지 아시나요?
: DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.
  DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 
 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때, 
 Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.

### 16. Spring의 AOP란?
: AOP는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하
 고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드 처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식으로
 이러한 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에
 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.

### 17. Filter와 Interceptor 방식의 차이?
: 

### 18. 디자인 패턴 아는 것?
1) 싱글톤(SingleTone Pattern) : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우
 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.
2) 팩토리 패턴(Factory pattern) : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는
   생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.
3) 옵저버 패턴(Observer Pattern) : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로
    사용됩니다.

### 19. MVC 패턴이란?
- Model : data 처리와 접근을 담당
- View : Client에 보여지는 화면을 담당
- Controller : Model과 View를 제어
하는 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.

### 20. 프로젝트 개발 순서??

1) 요구사항 분석 
기획 및 스토리 보드 작성
2) WBS(Work Breakdown Structure) 작성 : 작업 분해도로 프로젝트 범위와 최종산출물을 세부요소로 분할한 계층적 구조도
3) 논리 ERD 작성
4) 물리 ERD 작성
5) 개발
6) Testing
7) 유지보수

### 21. 오버로딩과 오버라이딩의 차이?
- 오버로딩 : 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식
- 오버라이딩 : 상속한 자식에서 부모의 메서드를 재정의하는 방식

### 22. Servlet vs JSP
- Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것
- JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것

### 23. Wrapper Class의 사용이유를 아나요?
: 기본 data 타입은 객체가 아니어서 Object로 받는 다형성을 지원할 수가 없다. 하지만, 메서드에서 실재로 기본데이터 타입을 다형성으로
 넘겨주어야 하는 경우가 빈번히 발생하는데 이때, 기본 데이터 타입을 객체로 변환시켜 전달하기 위해 사용되며
 최근에는 AUTO Boxing, AUTO UnBoxing이 지원된다.

### 24. DataBase에서 Index란?
: Table에 대한 동작 속도를 높여주는 자료구조로서 빠른 검색을 가능하게 해준다.

### 25. private, protected, public, default 제어자에 대해 설명해 보시오
- private : 같은 class 내부에서"만" 접근이 가능하다.
- public : 어디서든 자유롭게 접근이 가능하다.
- protected : 같은 class 내부 + 상속받은 자식에서는 부모 class에 접근이 가능하다.
- default : 아무 것도 선언하지 않은 경우로 같은 패키지 내부에서만 접근이 가능하다.

### 26. SI가 무엇을 하는 건지 알고 오셨나요?
: System Integration의 약자로 시스템 통합 사업으로 고객의 기존 전산시스템을 통합하거나 새로운 시스템을 구축하는 작업입니다.

### 27. SW 개발시 가장 비중을 크게 두어야 할 부분은 어디라고 생각하나요?
: Testing 부분입니다. 

### 28. 자바의 제네릭이란??

: 클래스 내부에서 사용할 데이터 타입을 인스턴스(객체) 생성시에 결정짓는 방식

### 29. 네트워크 OSI 7 Layer란?

#### Open System Interconnection

- 네트워킹 또는 무선통신 시스템의 기능을 설명하는 핵심 개념
- IT기업은 고객에게 신제품을 설명할 때 OSI 모형을 많이 활용한다
- (해당 제품이 어떤 계층에서 작동하는지 or 스택 전체에 걸쳐 작동하는지 설명한다)

|계층|역할|기능|
|:--:|:--:|:--|
|7계층 | 응용계층(Application)|응용계층은 가장 위에 있고 사용자에게 보이는 부분이다. OSI 모형에서는 최종 사용자에게 가장 가까운 계층이며 사용자와 직접적으로 상호작용한다. 크롬, 파이어폭스, 사파리등 웹브라우저와, 스카이프, 아읏룩, 오피스등의 응용프로그램등이 대표적인 응용계층에 속한다.|
|6계층 |표현계층(Presentation)|표현계층은 응용계층의 데이터 표현에서 독립적인 부분을 나타낸다. 응용프로그램 형식을 준비 또는 네트워크 형식으로 변환하거나 반대로 변환시키는 것을 나타낸다.이 계층은 데이터를 “표현”하는 것이며 대표적인 예로 데이터를 안전하게 전송하기 위한 암호화, 복호화 등이 있다.|
|5계층 | 세션계층(Session) |2대의 기기, 즉 컴퓨터 또는 서버간의 “통신” 및 “대화” 가 필요하면 세션을 만들어야 하는데 이 작업이 이 계층에서 처리된다.|
|4계층 | 전송계층(Transport) | 전송 계층은 최종 시스템 및 호스트 간의 데이터 전송 조율을 담당한다. 보낼 데이터의 용량과 속도, 목적지 등을 처리한다. 대표적으로 TCP(전송 제어 프로토콜)이 있     다. TCP는 인터넷 프로토콜 위에 구축되는데 흔히 TCP/IP로 알려져 있다.|
|3계층 | 네트워크 계층(Network) | 라우터 기능 대부분이 여기 네트워크 계층에 자리 잡는다. 다른 여러 라우터를 통한 라우팅을 비롯한 패킷 전달을 담당한다. 예를 들어 보스턴에 있는 컴퓨터가 캘리포    니아에 있는 서버에 연결하려 할때 그 경로는 수백만 가지인데 이 계층의 라우터가 이 작업을 효율적으로 처리한다.(라우터란 둘 혹은 그 이상의 네트워크와 네트워크      간의 데이터 전송을 위해 최적의 경로를 설정하며 통신망에서 다른 통신망으로 연결해주는 인터넷 접속장비이다) 즉 네트워크를 통해 정보를 주고 받을때 데이터에 담    긴 수신처의 주소를 읽고 가장 적절한 통신 통로를 다른 통신망으로 전송하는 장치 (전화국과 비슷한 개념)|
|2계층 | 데이터링크계층(Data Link)|이 계층은 두개의 직접연결된 노드 간의 데이터 전송을 제공하며 물리 계층의 오류 수정도 처리한다. 여기에 2개의 부계층도 존재하는데 하나는 매체 접근제어(MAC)     계층이고 다른 하나는 논리적연결제어(LLC)계층이다. 네트워킹 세계에서 대부분 스위치(네트워크단위들을 연결하는 통신 장비, 전송거리를 연장하며, 신호를 멀리 전     송할 수 있다)는 2계층에서 작동한다.|
|1계층 | 물리계층(Physical) | 가장 마지막의 물리계층 전기적, 물리적 표현을 나타낸다. 케이블의 종류, 무선주파수 링크, 핀배치, 전압, 물리요건등 포함된다. 네트워킹에 문제가 발생하면 네트워크     의 물리 계층을 확인한다(케이블 연결, 라우터나, 스위치 또는 컴퓨터에 전원 플러그가 빠졌는지 확인)|


### 30. 스프링 MVC 웹 요청 처리과정

>1. 클라이언트가 서버에 어떤 요청을 하면 DispatcherServlet이라는 클래스가 요청을 가로챈다.
>2. 가로 챈 DispatcherServlet 매핑값을 찾아 Controller에 요청을 처리할 메소드에 도달한다.
>3. 컨트롤러에서 해당 요청을 처리할 서비스에서 보내 DB에 접근이 필요하면 DAO에게 위임한다.
>4. DAO는 마이바티스 설정을 이용하여 SQL 쿼리를 날려 DB에 저장된 정보를 VO에 받아 서비스로 돌려준다.
>5. 모든 로직을 끝낸 서비스는 컨트롤러에 넘기고 컨트롤러는 Model객체에 결과물을 어떤 view로 보여줄 것인지 정보를 담아 디스패처서블릿에게 보낸다.
>6. DispatcherServlet은 응답할 View를 찾고 View는 응답로직을 처리한다.
>7. DispatcherServlet이 클라이언트에게 렌더링된 View를 응답한다.



### 31. Join이란?

- 둘 이상의 테이블에서 테이블 간의 데이터를 검색하여 결과 집합을 만드는 것을 말한다.
- Inner Join (교집합, 기준 테이블 A와 Join한 테이블 B의 중복 값) : SELECT 조회 목록 FROM 테이블 A JOIN 테이블 B on A.code=B.code
- Left Join (왼쪽 테이블 A 전체와 A|B 테이블의 중복값) : SELECT 조회 목록 FROM 테이블 A LEFT OUTER JOIN 테이블 B on A.code = B.code
- Right Join (오른쪽 테이블 B 전체와 A|B 테이블의 중복값) : SELECT 조회 목록 FROM 테이블 A RIGHT OUTER JOIN 테이블 B on A.code = B.code
- Cross Join (모든 경우의 수 전체 값) : SELECT 조회 목록, FROM 테이블 A CROSS JOIN 테이블 B
- Self Join (자기 자신이 가지고 있는 컬럼을 변형, 활용한 값) SELECT 조회 목록, FROM 테이블 별칭, 테이블 별칭2

### 32. Model 1과 Model 2의 차이점


|Model 1| Model2|
|:--|:--|
|- 뷰와 컨트롤러가 같은 jsp 안에서 실행 (JSP 혼자서 거의 모든 업무 처리)|-컨트롤러와 뷰가 구분|
|- 간단한 웹어플리케이션 구축할때 적당|- 뷰는 어떠한 처리로직도 포함되지 않음|
|- 개발기간 단축|-사용자의 요청의 진입점은 컨트롤러인 서블릿이 통제(서블릿이 거의 업무 처리)|
|- 유지보수 어려움|-유지보수, 확장에 용이|


### 33. JAVA의 특징

- 자바가상머신(JVM)만 설치하면 컴퓨터의 운영체제에 상관없이 작동한다.(즉, 운영체제에 독립적)
- 기본 자료형을 제외한 모든 요소들이 객체로 표현
- 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
- Garbage Collector를 통한 자동적인 메모리 관리
- 멀티쓰레드(Multi-thread)를 지원


### 34. OOP(객체지향 프로그래밍)

- OOP란 Object-Oriented Programming의 약어로써 객체지향 프로그래밍을 의미
- 데이터를 객체로 취급하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는 다르게 객체와 객체의 상호작용을 통해 프로그램이 동작하는    것을 말한다.

### 35. OOP 특징

- 객체지향 프로그래밍은 코드의 재사용성이 높다.
- 코드의 변경이 용이
- 직관적인 코드분석
- 개발속도 향상 / 상속을 통한 장점 극대화

 

### 36. 객체란 ? Object

- Object(객체)는 OOP에서 데이터(변수)와 그 데이터에 관련되는 동작(함수). 즉 절차, 방법, 기능을 모두 포함한 개념
- 기차역에서 승차권을 발매하는 경우, 실체인 '손님'과 동작인 '승차권 주문'은 하나의 객체이며, 실체인 '역무원'과 동작인 '승차권 발매'도 하나의 객체이다.


### 37. Overloading vs Overriding ? 


|Overloading(오버로딩)|Overriding(오버라이딩)|
|:--:|:--:|
|- 같은 이름의 메소드를 여러개 정의하는 것| - 상속에서 나온 개념|
|- 매개변수의 타입이 다르거나 개수가 달라야 한다.| 상위 클래스(부모 클래스)의 메소드를 하위 클래스(자식 클래스)에서 재정의)|
|- return type과 접근 제어자는 영향을 주지 않음.||

### 38. Servlet, JSP

- Servlet : Container가 이해할 수 있게 구성된 순수 자바 코드로만 이루어진 것(Html in JAVA)
- JSP(Java Server Page) - html기반에 JAVA코드를 블록화하여 삽입한 것(JAVA in Html)

### 39. 자바 컬렉션의 대표 인터페이스

##### List
- 순서가 있는 데이터의 집합으로 데이터의 중복을 허용하며 인덱스로 조회한다.
##### Set
- 순서를 유지하지 않는 데이터의 집합으로 데이터의 중복을 허용하지 않는다.
##### Map
- 키와 벨류값의 쌍으로 이루어진 데이터 집합으로 순서는 유지되지 않으며 키는 중복은 허용하지 않지만 벨류값은 중복을 허용한다.



### 40. JDBC 

- Java Data Base Connection의 약자로 JAVA 언어를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍을 의미

### 41. Get과 Post 방식

|Get 방식|Post 방식|
|:--|:--|
|- 클라이언트에서 서버로 데이터를 전달할 때, 주소 뒤에 "이름"과 "값"이 결합된 스트링 형태로 전달 |- 일정 크기 이상의 데이터를 보내야 할 때 사용한다.|
|- 주소창에 쿼리 스트링이 그대로 보여지기 때문에 보안성이 떨어진다.|- 서버로 보내기 전에 인코딩하고, 전송 후 서버에서는 다시 디코딩 작업을 한다|
|- 길이에 제한이 있다.(=전송 데이터의 한계가 있다.)|- 주소창에 전송하는 데이터의 정보가 노출되지 않아 Get방식에 비해 보안성이 높다.|
|- Post방식보다 상대적으로 전송 속도가 빠르다.|- 속도가 Get방식보다 느리다.|
||- 쿼리스트링(문자열) 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 객체들의 값도 전송가능.|


### 42. Get과 Post 차이점

|Get 방식|Post 방식|
|:--|:--|
|- Get은 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용|- Post는 웹 브라우저가 웹 서버에 데이터를 전달하기 위해 사용.|
|- Get을 사용하면 웹 브라우저에서 웹 서버로 전달되는 데이터가 인코딩되어 URL에 붙는다.|- Post방식은 전달되는 데이터가 보이지 않는다.|
|- Get방식은 전달되는 데이터가 255개의 문자를 초과하면 문제가 발생할 수 있다.|- 웹서버에 많은 데이터를 전달하기 위해서는 Post 방식을 사용하는 것이 바람직하다.|
 
### 43.Session과 Cookie

Session과 Cookie 사용 이유
- 현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다 새로운 접속이 이루어지며 이전 페이       지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP프로토콜을 이용하게 되는 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문     자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.

|Session|Cookie|
|:--|:--|
|- 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한번의 방문을 의미한다.|- 사용자 정보를 유지할 수 없다는 HTTP의 한계를 극복할 수 있는 방법|
|- Session에 관련된 데이터는 Server에 저장된다.|- 인터넷 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보이다.|
|- 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라진다.|- Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써, Server가 아닌 Client에 텍스트     파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.|
|- Cookie에 비해 보안성이 좋다.|- Cookie는 Client PC에 저장되는 정보기 때문에, 다른 사용자에 의해서 임의로 변경이 가능하다.(정보 유출 가능, Session보다 보안성이 낮은 이유)|
 

 

### 44. 보안성이 낮은 Cookie 대신 Session을 사용하면 되는데 안하는 이유?
- 모든 정보를 Session에 저장하면 Server의 메모리를 과도하게 사용하게 되어 Server에 무리가 가기 때문이다.

### 45. MVC란?

- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다.
- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평     가하고 있다.

### 46. MVC 구성요소

- Model : 소프트웨어 응용과 관련된 고급 클래스 내의 논리적 데이터 기반 구조를 표현. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.
- View : 사용자 인터페이스 내의 구성요소들을 표현(사용자에게 보여지는 화면)
- Controller : Model과 View를 연결하고 있는 클래스를 대표, Model과 View 내의 클래스들 간 정보 교환하는데 사용


### 47. Interface, Abstract 

|Interface|Abstract|
|:--|:--|
|- 클래스가 아니다.|- 추상메서드를 하나 이상 가진 클래스|
|- 오직 추상메서드와 상수만을 멤버로 갖는다.|- 자신의 생성자로 객체 생성 불가능|
|- Implements 키워드를 사용|- 하위 클래스를 참조하여 상위 클래스의 객체를 생성|
|- 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.|- 하위 클래스를 제어하기 위해 사용|
|- Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.||
 

|Interface vs Abstract||
|:--|:--|
|공통점|차이점|
|- new 연산자로 인스턴스 생성 불가능.|사용하는 키워드가 다르다.
|- 프로토타입만 있는 메서드를 갖는다|- Abstract는 일반 메서드를 사용할 수 있지만, Interface는 메서드 선언만 가능하다.|
|- 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.||

### 48. Call by Reference, Call by Value

- Call by Reference :  매개 변수의 원래 주소에 값을 저장하는 방식. 클래스 객체를 인수로 전달한 경우

- Call by Value : 인수로 기본 데이터형을 사용. 주어진 값을 복사하여 처리하는 방식. 메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않는다.

 ### 49. Static의 의미 

- 클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미
- 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(객체와 무관한 키워드)

 ### 50. Framework

- 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스프레임과 인터페이스 프레임의 집합

- 특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업시간을 줄여주는 것이다. 

- 프레임워크는 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성된다.

- 프레임워크는 이렇게 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.

- 프레임워크 컴포넌트 들은 재사용이 가능하다.

- 프레임워크는 좀 더 높은 수준에서 패턴을 조작한다.

- 프레임워크가 중요한 이유는 객체지향 개발을 하게 되면서 개발자의 취향에 따라 다양한 프로그램이 나오게 되었다. 프로그램 개발에 투입되는 개발자도 점점 늘어         남에 따라 전체 시스템의 통합성, 일관성이 부족하게 되었기 때문이다. 그래서 개발자의 자유를 제한하기 위해 프레임워크를 도입했다.

 

### 51. 프레임워크가 가져야할 특징

- 개발자들이 따라야할 가이드라인을 가진다.

- 개발할 수 있는 범위가 정해져 있다.

- 개발자를 위한 다양한 도구들이 지원된다.

 
### 프레임워크의 장/단점

장점 - 개발 시간을 줄일 수 있고 오류로부터 자유로울 수 있다.

단점 - 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해지는 점이다.

 

 

### 52. Garbage Collection(가비지 컬렉션)

- 시스템에서 더이상 사용하지 않는 동적 할당된 메모리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것으로 시스템에서 가비지컬렉션을 수행하는 부분       을 가비지 컬렉터라 부른다.

### 53. Primitive type과 Reference type
- Primitive type : 변수에 값 자체를 저장 
- 정수형 byte, short, int, long
- 실수형 float, double
– 문자형 char
- 논리형 boolean



    #### Primitive type은 Wrapper Class를 통해 객체로 변형할 수 있다. 

    예) int→Integer, char→Character(int와 char를 제외한 Primitive type의 다른 자료형들은 맨 앞 알파벳을 대문자로 바꿔주면 된다. float→Float)

    

    - Reference type : 메모리상에 객체가 있는 위치를 저장

    - 종류 : Class, Interface, Array

 
    #### Wrapper Class

    - Primitive type으로 표현할 수 있는 간단한 데이터를 객체로 만들어야 할 경우가 있는데 그러한 기능을 지원하는 클래스

 

 

### 54. Spring Framework(스프링 프레임워크)

- 자바(JAVA) 플랫폼을 위한 오픈소스(Open Source) 애플리케이션 프레임워크(Framework)

- 자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임워크

- 자바 개발을 위한 프레임워크로 종속 객체를 생성해주고,  조립해주는 도구

- 자바로 된 프레임워크로 자바SE로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할

- 관점지향 프로그래밍(AOP)을 위한 풍부한 지원

- 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음

- 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음


### 55. Spring의 특징


|Spring 특징| 설명|
|:--|:--|
|1. 경량 컨테이너로서 자바 객체를 직접 관리| 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.|
|2. 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크| 일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.|
|3. 스프링은 제어의 역행(IoC : Inversion of Control)을 지원| 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.|
|4. 스프링은 의존성 주입(DI : Dependency Injection)을 지원 | 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.|
|5. 스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원| 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.|
|6. 스프링은 영속성(dao,영속객체,persistence)과 관련된 다양한 서비스를 지원 | 객체관계매핑(ORM – Object Relational mapping) DB와 객체지향프로그래밍 언어간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법 iBatis나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.|
| 7. 스프링은 확장성이 높음 | 스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.|

### 56. 쓰레드와 장점 단점? 
Thread
Thread(쓰레드) - 프로세스내에서 동시에 실행되는 독립적인 실행 단위를 말함, 장점으로는 자원을 많이 사용하지 않고 구현이 쉬우며 범용성이 높다
Process(프로세스) - 운영체제에서 실행중인 하나의 프로그램(하나 이상의 쓰레드를 포함한다.)

#### Thread 장점
- 빠른 프로세스 생성
- 적은 메모리 사용
- 쉬운 정보 공유

#### Thread 단점
- 교착상태에 빠질 수 있다.
- 교착상태 : 다중프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 어떤 특정시간을 기다리고 있는 상태.

### 57. Thread와 Process 차이
- 여러 분야에서 '과정' 또는 '처리'라는 뜻으로 사용되는 용어로 컴퓨터 분야에서는 "실행중인 프로그램" 이라는 뜻으로 쓰인다.
- 이 프로세스 내에서 실행되는 각각의 일을 스레드라고 한다. 프로세스 내에서 실행되는 세부 작업 단위로 여러 개의 스레드가 하나의 프로세스를 이루게 되는 것이다.

### 58. 접근제한자(public > protected > default > private)
public - 접근 제한이 없다.(같은 프로젝트 내에 어디서든 사용가능)
protected - 같은 패키지 내, 다른 패키지에서 상속받아 자손클래스에서 접근 가능 
default - 같은 패키지 내에서만 접근 가능
private - 같은 클래스 내에서만 접근 가능

### 59. 소켓 통신(TCP/UDP)
#### TCP(Transmission Control Protocol)
- 연결형 서비스 제공(연결된 상태에서 서비스제공)
- 높은 신뢰성 보장
- 연결의 설정(3-way handshaking)
- 연결의 해제(4-way handshaking)
- 데이터 흐름 제어, 혼잡 제어
- 전이중, 점대점 서비스(양방향 송수신 서비스)

#### UDP(User Datagram Protocol)
- 비연결형 서비스 제공(연결되지 않은 상태에서 서비스제공) 동영상, 음성, 멀티미디어
- 신뢰성이 낮음
- 데이터의 전송 순서가 바뀔 수 있음
- 데이터 수신 여부 확인 안함(3-way handshaking과 같은 과정 X)
- TCP보다 전송속도가 빠름


### 60.STACK, QUEUE
#### STACK
- LIFO(Last In First Out)의 후입선출 구조
- push();를 이용한 데이터 입력, pop();을 이용한 데이터 출력
- 예) 시스템 스택 : 함수의 호출과 복귀 순서는 스택의 구조를 응용하여 관리
- 역순 문자열 만들기, 수식의 괄호 검사, 수식의 후위 표기법 변환

#### QUEUE
- FIFO(First In First Out)의 선입선출 구조
- enQueue();를 이용한 데이터 입력, deQueue();를 이용한 데이터 출력
- 예) 우선순위가 같은 작업 예약(인쇄 대기열), 선입선출이 필요한 대기열(티켓 카운터)
- Linear Queue(선형큐)는 메모리 재사용이 불가능 이러한 문제점을 보완하여 Circular Queue(원형 큐)가 나옴


### 61. Singleton Design Pattern(싱글톤 디자인 패턴, 싱글톤 패턴)
- 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공한다.

### 62. Database에서 Index란?
- 인덱스는 데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 일컫는다.
- 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다.
- 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.
- 사용자는 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 인덱스를 생성하고 사용한다.

### 63. 트랜잭션
- Database에서 한꺼번에 수행되어야 할 일련의 연산들
- 하나의 논리적 작업단위로 수행되는 작업, 즉 sql의 묶음


### 64. 프로젝트 진행 과정
- 요구사항분석 – 설계(DB,클래스,화면) – 개발 – 테스트 – 이관/교육 – 프로젝트 종료


### 100. 그 외 개인 질문

- 자기 소개
- 프로젝트의 내용과 맡은 역할
- 프로젝트 진행시 어려웠던 부분과 극복한 사례
- 자신 있는 것 기술
- 희망연봉과 이유
- 회사에 대해 질문이나 궁금한 점
- 개발자가 되고자 하는 이유
- 사회 경험에 대한 내용
- 개발자로서의 꿈
- 취미, 특기









#### 출처
[1. 자바 경력 기술 면접 질문 리스트](https://js2prince.tistory.com/entry/java-경력-기술-면접-질문-리스트)
[2.자바 개발 기술 면접 질문 리스트](https://easy-h.tistory.com/2)
